// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package treeviewsuite.actions;

import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.UserAction;
import java.util.*;

public class GenerateTestTreeData extends UserAction<java.lang.Boolean>
{
	private final java.lang.Long nodeCount;
	private final java.lang.Long maxDepth;
	private final java.lang.Long startLevel;

	public GenerateTestTreeData(
		IContext context,
		java.lang.Long _nodeCount,
		java.lang.Long _maxDepth,
		java.lang.Long _startLevel
	)
	{
		super(context);
		this.nodeCount = _nodeCount;
		this.maxDepth = _maxDepth;
		this.startLevel = _startLevel;
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE

		// Validate inputs
        if (nodeCount == null || nodeCount <= 0) {
            throw new IllegalArgumentException("Node count must be greater than 0");
        }
        if (maxDepth == null || maxDepth <= 0) {
            throw new IllegalArgumentException("Max depth must be greater than 0");
        }
        if (startLevel == null || startLevel < 0) {
            throw new IllegalArgumentException("Start level must be 0 or greater");
        }
        
        // Initialize random generator
        Random random = new Random();
        
        // Track created nodes
        List<IMendixObject> currentBatch = new ArrayList<>();
        List<IMendixObject> allCreatedNodes = new ArrayList<>(); // Track all nodes for final association setting
        Queue<NodeInfo> nodesToProcess = new LinkedList<>();
        Map<String, IMendixObject> nodeMap = new HashMap<>(); // Map nodeId to IMendixObject for associations
        Map<String, String> structureToNodeIdMap = new HashMap<>(); // Map structureId to nodeId
        
        int createdNodes = 0;
        int currentSortOrder = 1;
        int totalCommitted = 0;
        int nextRootStructureId = 1; // Track next available root structure ID
        
        // Create root nodes
        int rootCount = Math.min(5, Math.max(1, random.nextInt(6)));
        for (int i = 0; i < rootCount && createdNodes < nodeCount; i++) {
            String rootCategory = CATEGORY_HIERARCHY[0][i % CATEGORY_HIERARCHY[0].length];
            String nodeId = UUID.randomUUID().toString();
            String structureId = String.valueOf(nextRootStructureId++) + ".";
            
            IMendixObject rootNode = createNode(
                nodeId,
                null,                                    // No parent ID
                null,                                    // No parent structure ID
                structureId,                             // Structure ID
                startLevel.intValue(),                   // Level (configurable starting level)
                currentSortOrder++,                      // Sort order
                rootCategory + " " + (i + 1),           // Name
                "Test root node for " + rootCategory,   // Description
                rootCategory                             // Category
            );
            
            currentBatch.add(rootNode);
            allCreatedNodes.add(rootNode);
            nodeMap.put(nodeId, rootNode);
            structureToNodeIdMap.put(structureId, nodeId);
            createdNodes++;
            
            // Add to processing queue
            nodesToProcess.offer(new NodeInfo(nodeId, structureId, rootCategory, startLevel.intValue(), i));
            
            // Commit batch if needed
            if (currentBatch.size() >= BATCH_SIZE) {
                Core.commitWithoutEvents(getContext(), currentBatch);
                totalCommitted += currentBatch.size();
                currentBatch.clear();
                
                // Log progress
                Core.getLogger(this.getClass().getName()).info(
                    String.format("Progress: %d/%d nodes created", totalCommitted, nodeCount)
                );
            }
        }
        
        // Process nodes level by level using queue
        List<NodeInfo> currentLevelNodes = new ArrayList<>();
        
        while (createdNodes < nodeCount) {
            // If queue is empty but we need more nodes
            if (nodesToProcess.isEmpty()) {
                // Option 1: Create more root nodes
                if (currentLevelNodes.isEmpty() || createdNodes < nodeCount * 0.1) {
                    // Create additional root nodes
                    int additionalRoots = Math.min(10, (int)((nodeCount - createdNodes) * 0.1));
                    for (int i = 0; i < additionalRoots && createdNodes < nodeCount; i++) {
                        String rootCategory = CATEGORY_HIERARCHY[0][(rootCount + i) % CATEGORY_HIERARCHY[0].length];
                        String nodeId = UUID.randomUUID().toString();
                        String structureId = String.valueOf(nextRootStructureId++) + ".";
                        
                        IMendixObject rootNode = createNode(
                            nodeId,
                            null,
                            null,
                            structureId,
                            startLevel.intValue(),  // Level (configurable starting level)
                            currentSortOrder++,
                            rootCategory + " Extra " + (rootCount + i + 1),
                            "Additional root node for " + rootCategory,
                            rootCategory
                        );
                        
                        currentBatch.add(rootNode);
                        allCreatedNodes.add(rootNode);
                        nodeMap.put(nodeId, rootNode);
                        structureToNodeIdMap.put(structureId, nodeId);
                        createdNodes++;
                        rootCount++;
                        
                        nodesToProcess.offer(new NodeInfo(nodeId, structureId, rootCategory, startLevel.intValue(), rootCount - 1));
                        
                        // Commit batch if needed
                        if (currentBatch.size() >= BATCH_SIZE) {
                            Core.commitWithoutEvents(getContext(), currentBatch);
                            totalCommitted += currentBatch.size();
                            currentBatch.clear();
                        }
                    }
                }
                
                // Option 2: Re-process nodes from previous levels to add more children
                else if (!currentLevelNodes.isEmpty()) {
                    // Add nodes back to queue to generate more children
                    for (NodeInfo node : currentLevelNodes) {
                        if (node.level < startLevel + maxDepth - 1) {
                            nodesToProcess.offer(node);
                        }
                    }
                    currentLevelNodes.clear();
                }
                
                // If still empty and can't generate more, break
                if (nodesToProcess.isEmpty()) {
                    Core.getLogger(this.getClass().getName()).warn(
                        String.format("Cannot generate more nodes. Reached maximum tree capacity at %d nodes", createdNodes)
                    );
                    break;
                }
            }
            
            NodeInfo parentInfo = nodesToProcess.poll();
            
            // Skip if we've reached max depth (adjust for start level)
            if (parentInfo.level >= startLevel + maxDepth - 1) {
                continue;
            }
            
            // Determine child count - ensure minimum children for sparse trees
            int childCount = getRandomChildCount(random, parentInfo.level, maxDepth.intValue());
            
            // If we're far from target, ensure at least some children
            if (createdNodes < nodeCount * 0.7 && parentInfo.level < startLevel + maxDepth - 2) {
                childCount = Math.max(1, childCount);
            }
            
            // Create children
            boolean createdAnyChildren = false;
            for (int i = 0; i < childCount && createdNodes < nodeCount; i++) {
                String childNodeId = UUID.randomUUID().toString();
                String childStructureId = parentInfo.structureId + (i + 1) + ".";
                String childCategory = generateChildCategory(
                    parentInfo.category, 
                    parentInfo.level + 1, 
                    parentInfo.rootIndex,
                    i,
                    random
                );
                String childName = generateNodeName(random, childCategory, i + 1, parentInfo.level + 1);
                String childDescription = generateDescription(random, childName, parentInfo.level + 1);
                
                IMendixObject childNode = createNode(
                    childNodeId,
                    parentInfo.nodeId,
                    parentInfo.structureId,
                    childStructureId,
                    parentInfo.level + 1,
                    currentSortOrder++,
                    childName,
                    childDescription,
                    childCategory
                );
                
                currentBatch.add(childNode);
                allCreatedNodes.add(childNode);
                nodeMap.put(childNodeId, childNode);
                structureToNodeIdMap.put(childStructureId, childNodeId);
                createdNodes++;
                createdAnyChildren = true;
                
                // Add child to processing queue
                nodesToProcess.offer(new NodeInfo(
                    childNodeId,
                    childStructureId,
                    childCategory,
                    parentInfo.level + 1,
                    parentInfo.rootIndex
                ));
                
                // Track current level nodes for potential re-processing
                currentLevelNodes.add(new NodeInfo(
                    childNodeId,
                    childStructureId,
                    childCategory,
                    parentInfo.level + 1,
                    parentInfo.rootIndex
                ));
                
                // Commit batch if needed
                if (currentBatch.size() >= BATCH_SIZE) {
                    Core.commitWithoutEvents(getContext(), currentBatch);
                    totalCommitted += currentBatch.size();
                    currentBatch.clear();
                    
                    // Log progress
                    if (totalCommitted % 10000 == 0) {
                        Core.getLogger(this.getClass().getName()).info(
                            String.format("Progress: %d/%d nodes created", totalCommitted, nodeCount)
                        );
                    }
                    
                    // Force garbage collection periodically for large datasets
                    if (totalCommitted % 50000 == 0) {
                        System.gc();
                    }
                }
            }
        }
        
        // Commit remaining nodes
        if (!currentBatch.isEmpty()) {
            Core.commitWithoutEvents(getContext(), currentBatch);
            totalCommitted += currentBatch.size();
        }
        
        // Set all parent associations at the end after all nodes are committed
        Core.getLogger(this.getClass().getName()).info(
            "Setting parent associations for all nodes..."
        );
        setParentAssociations(allCreatedNodes, nodeMap, structureToNodeIdMap);
        
        // Log summary
        Core.getLogger(this.getClass().getName()).info(
            String.format("Successfully generated %d tree nodes", totalCommitted)
        );
        
        return true;
		
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "GenerateTestTreeData";
	}

	// BEGIN EXTRA CODE
	
    // Category definitions for different levels
    private static final String[][] CATEGORY_HIERARCHY = {
        // Level 0 - Root categories
        {"Animals", "Plants", "Technology", "Geography", "Science"},
        // Level 1 - Subcategories for each root
        {"Mammals", "Birds", "Reptiles", "Fish", "Insects"},           // Animals
        {"Trees", "Flowers", "Vegetables", "Fruits", "Herbs"},         // Plants
        {"Hardware", "Software", "Networks", "AI", "Robotics"},        // Technology
        {"Continents", "Countries", "Cities", "Rivers", "Mountains"},  // Geography
        {"Physics", "Chemistry", "Biology", "Mathematics", "Astronomy"} // Science
    };
    
    // Level 2+ subcategories
    private static final String[][] DEEP_SUBCATEGORIES = {
        // Mammals subcategories
        {"Primates", "Carnivores", "Herbivores", "Rodents", "Marine Mammals"},
        // Birds subcategories
        {"Raptors", "Songbirds", "Waterfowl", "Flightless", "Tropical"},
        // Generic subcategories for deeper levels
        {"Alpha Type", "Beta Type", "Gamma Type", "Delta Type", "Epsilon Type"},
        {"Primary", "Secondary", "Tertiary", "Quaternary", "Special"},
        {"Group A", "Group B", "Group C", "Group D", "Group E"}
    };
    
    // Batch size for commits (balance between memory and performance)
    private static final int BATCH_SIZE = 1000;
    
    /**
     * Creates a single tree node entity
     */
    private IMendixObject createNode(String nodeId, String parentNodeId, String parentStructureId, 
                                    String structureId, int level, int sortOrder, 
                                    String name, String description, String category) throws Exception {
        
        IMendixObject node = Core.instantiate(getContext(), "TreeViewSuite.TreeNode");
        
        // Set basic attributes - use empty string instead of null for root nodes
        node.setValue(getContext(), "TreeItemID", nodeId);
        node.setValue(getContext(), "ParentTreeItemID", parentNodeId != null ? parentNodeId : "");
        node.setValue(getContext(), "StructureID", structureId);
        // Parent structure ID should be empty for root nodes, otherwise remove the trailing dot
        String parentStructId = "";
        if (parentStructureId != null && !parentStructureId.isEmpty()) {
            // Parent structure ID is passed with trailing dot, which is correct
            parentStructId = parentStructureId;
        }
        node.setValue(getContext(), "ParentStructureID", parentStructId);
        node.setValue(getContext(), "Level", level);
        node.setValue(getContext(), "SortOrder", sortOrder);
        node.setValue(getContext(), "Name", name);
        node.setValue(getContext(), "Description", description);
        node.setValue(getContext(), "Category", category != null ? category : "Uncategorized");
        
        // Set boolean attributes
        node.setValue(getContext(), "IsExpanded", false);  // Start collapsed
        node.setValue(getContext(), "IsVisible", true);    // All nodes visible by default
        
        // Note: Parent association (TreeNode_ParentTreeNode) must be set after commit
        // when parent objects are available
        
        return node;
    }
    
    /**
     * Generate child category based on parent category and level
     */
    private String generateChildCategory(String parentCategory, int level, int rootIndex, 
                                       int childIndex, Random random) {
        String[] parentParts = parentCategory.split(";");
        String rootCategory = parentParts[0];
        
        // Determine subcategory based on level
        String subcategory;
        
        if (level == 1) {
            // Use predefined subcategories for level 1
            int categorySetIndex = rootIndex % CATEGORY_HIERARCHY.length;
            if (categorySetIndex < CATEGORY_HIERARCHY.length && categorySetIndex > 0) {
                String[] subcategories = CATEGORY_HIERARCHY[categorySetIndex];
                subcategory = subcategories[childIndex % subcategories.length];
            } else {
                // Fallback for Animals (index 0)
                String[] animalSubcategories = CATEGORY_HIERARCHY[1];
                subcategory = animalSubcategories[childIndex % animalSubcategories.length];
            }
        } else if (level == 2) {
            // Use deep subcategories for level 2
            int subIndex = childIndex % DEEP_SUBCATEGORIES[0].length;
            subcategory = DEEP_SUBCATEGORIES[0][subIndex];
        } else {
            // For deeper levels, use generic subcategories
            int setIndex = (level - 3) % (DEEP_SUBCATEGORIES.length - 2) + 2;
            int subIndex = childIndex % DEEP_SUBCATEGORIES[setIndex].length;
            subcategory = DEEP_SUBCATEGORIES[setIndex][subIndex];
        }
        
        // Build full category path
        return parentCategory + ";" + subcategory;
    }
    
    /**
     * Get random child count with realistic distribution
     * Ensures better tree expansion for large node counts
     */
    private int getRandomChildCount(Random random, int currentLevel, int maxDepth) {
        // Fewer children as we go deeper
        double depthFactor = 1.0 - ((double) currentLevel / maxDepth);
        
        // Use normal distribution centered around 4 (increased from 3 for better expansion)
        double gaussian = random.nextGaussian() * 1.5 + 4;
        int childCount = (int) Math.round(gaussian * depthFactor);
        
        // Clamp between 0 and 12 (increased max for better expansion)
        return Math.max(0, Math.min(12, childCount));
    }
    
    /**
     * Generate realistic node names based on category
     */
    private String generateNodeName(Random random, String category, int childIndex, int level) {
        String[] categoryParts = category.split(";");
        String leafCategory = categoryParts[categoryParts.length - 1];
        
        // Sometimes use the category in the name
        if (random.nextDouble() < 0.4) {
            return leafCategory + " " + (char)('A' + random.nextInt(26)) + 
                   String.format("%03d", random.nextInt(1000));
        }
        
        // Otherwise generate a more specific name
        String[] suffixes = {"Unit", "Item", "Entity", "Object", "Element", "Component"};
        String suffix = suffixes[random.nextInt(suffixes.length)];
        
        return leafCategory + " " + suffix + " " + (childIndex + random.nextInt(100));
    }
    
    /**
     * Generate description based on name and level
     */
    private String generateDescription(Random random, String name, int level) {
        String[] templates = {
            "This is a test %s at level %d",
            "Sample data for %s (depth: %d)",
            "Test node: %s - Level %d in the hierarchy",
            "%s - Automatically generated test data at level %d",
            "Description for %s at tree depth %d"
        };
        
        String template = templates[random.nextInt(templates.length)];
        return String.format(template, name, level);
    }
    
    /**
     * Set parent associations for a batch of nodes
     */
    private void setParentAssociations(List<IMendixObject> nodes, Map<String, IMendixObject> nodeMap, Map<String, String> structureToNodeIdMap) throws Exception {
        List<IMendixObject> nodesToCommit = new ArrayList<>();
        
        for (IMendixObject node : nodes) {
            String parentTreeItemId = (String) node.getValue(getContext(), "ParentTreeItemID");
            
            // Skip root nodes (empty parent ID)
            if (parentTreeItemId != null && !parentTreeItemId.isEmpty()) {
                // Find parent node by TreeItemID
                IMendixObject parentNode = nodeMap.get(parentTreeItemId);
                
                if (parentNode != null) {
                    // Set the association using the parent's identifier
                    node.setValue(getContext(), "TreeViewSuite.TreeNode_ParentTreeNode", parentNode.getId());
                    nodesToCommit.add(node);
                } else {
                    Core.getLogger(this.getClass().getName()).warn(
                        String.format("Parent node not found for TreeItemID: %s", parentTreeItemId)
                    );
                }
            }
        }
        
        // Commit the associations if any were set
        if (!nodesToCommit.isEmpty()) {
            Core.commitWithoutEvents(getContext(), nodesToCommit);
        }
    }
    
    /**
     * Helper class to store node information in the processing queue
     */
    private static class NodeInfo {
        final String nodeId;
        final String structureId;
        final String category;
        final int level;
        final int rootIndex;
        
        NodeInfo(String nodeId, String structureId, String category, int level, int rootIndex) {
            this.nodeId = nodeId;
            this.structureId = structureId;
            this.category = category;
            this.level = level;
            this.rootIndex = rootIndex;
        }
    }
	// END EXTRA CODE
}
