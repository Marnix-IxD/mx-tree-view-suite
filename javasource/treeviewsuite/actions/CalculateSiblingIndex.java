// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package treeviewsuite.actions;

import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.IMendixIdentifier;
import com.mendix.systemwideinterfaces.core.UserAction;
import java.util.*;

/**
 * Calculates the sibling index for a TreeNode which represents its position
 * among its siblings (1-based). This minimal data allows the client to
 * deterministically generate structure IDs that match server-generated ones.
 * 
 * The sibling index is calculated by:
 * 1. Finding all siblings (nodes with same parent)
 * 2. Sorting them by SortOrder
 * 3. Determining this node's position (1-based)
 * 
 * This approach enables external navigation and consistent structure IDs
 * between client and server without transferring full structure IDs.
 * 
 * Note: Entity access should be configured in the calling microflow.
 * This action uses the provided context for all queries.
 */
public class CalculateSiblingIndex extends UserAction<java.lang.Long>
{
	private IMendixObject __TreeNode;
	private treeviewsuite.proxies.TreeNode TreeNode;

	public CalculateSiblingIndex(IContext context, IMendixObject _TreeNode)
	{
		super(context);
		this.__TreeNode = _TreeNode;
	}

	@java.lang.Override
	public java.lang.Long executeAction() throws Exception
	{
		this.TreeNode = this.__TreeNode == null ? null : treeviewsuite.proxies.TreeNode.initialize(getContext(), __TreeNode);

		// BEGIN USER CODE
		
		if (TreeNode == null) {
			throw new IllegalArgumentException("TreeNode parameter cannot be null");
		}
		
		// Get all siblings (including this node)
		List<IMendixObject> siblings = getSiblings();
		
		// Sort siblings by SortOrder
		sortBySortOrder(siblings);
		
		// Find this node's position (1-based)
		long siblingIndex = findNodePosition(siblings);
		
		// Store the sibling index on the node for future use
		TreeNode.setSiblingIndex(siblingIndex);
		
		// Log the result for debugging
		if (Core.getLogger(this.getClass().getName()).isDebugEnabled()) {
			Core.getLogger(this.getClass().getName()).debug(
				String.format("[CalculateSiblingIndex] Node: %s, Level: %d, Parent: %s, SiblingIndex: %d (out of %d siblings)", 
					TreeNode.getTreeItemID(), 
					TreeNode.getLevel(),
					TreeNode.getParentTreeItemID() != null ? TreeNode.getParentTreeItemID() : "ROOT",
					siblingIndex,
					siblings.size())
			);
		}
		
		return siblingIndex;
		
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "CalculateSiblingIndex";
	}

	// BEGIN EXTRA CODE
	
	/**
	 * Get all siblings of the current node (children of the same parent)
	 * @return List of sibling nodes including the current node
	 */
	private List<IMendixObject> getSiblings() throws Exception {
		// Check if this is a root node
		String parentTreeItemId = TreeNode.getParentTreeItemID();
		Integer level = TreeNode.getLevel();
		
		if (parentTreeItemId == null || parentTreeItemId.isEmpty()) {
			// This is a root node - get all nodes at the same level with no parent
			return Core.createXPathQuery("//TreeViewSuite.TreeNode[Level = $level and " +
					"(ParentTreeItemID = '' or empty(ParentTreeItemID))]")
				.addVariable("level", level)
				.execute(getContext());
		} else {
			// This is a child node - get all nodes with the same parent
			// First try to use the association if the parent is loaded
			IMendixIdentifier parentId = TreeNode.getTreeNode_ParentTreeNode();
			if (parentId != null) {
				// Use association-based query (more efficient)
				return Core.createXPathQuery("//TreeViewSuite.TreeNode[TreeViewSuite.TreeNode_ParentTreeNode = $parent]")
					.addVariable("parent", parentId)
					.execute(getContext());
			} else {
				// Fallback to ParentTreeItemID
				return Core.createXPathQuery("//TreeViewSuite.TreeNode[ParentTreeItemID = $parentId]")
					.addVariable("parentId", parentTreeItemId)
					.execute(getContext());
			}
		}
	}
	
	/**
	 * Sort nodes by SortOrder attribute
	 * @param nodes List of nodes to sort in-place
	 */
	private void sortBySortOrder(List<IMendixObject> nodes) {
		Collections.sort(nodes, new Comparator<IMendixObject>() {
			@Override
			public int compare(IMendixObject a, IMendixObject b) {
				try {
					Integer sortOrderA = (Integer) a.getValue(getContext(), "SortOrder");
					Integer sortOrderB = (Integer) b.getValue(getContext(), "SortOrder");
					
					// Handle null values - treat as 0
					if (sortOrderA == null) sortOrderA = 0;
					if (sortOrderB == null) sortOrderB = 0;
					
					return sortOrderA.compareTo(sortOrderB);
				} catch (Exception e) {
					Core.getLogger(CalculateSiblingIndex.class).error(
						"Error comparing sort orders: " + e.getMessage(), e
					);
					return 0;
				}
			}
		});
	}
	
	/**
	 * Find the position of the current node in the sorted sibling list
	 * @param siblings Sorted list of siblings
	 * @return 1-based position
	 */
	private long findNodePosition(List<IMendixObject> siblings) {
		IMendixIdentifier currentNodeId = TreeNode.getMendixObject().getId();
		
		for (int i = 0; i < siblings.size(); i++) {
			if (siblings.get(i).getId().equals(currentNodeId)) {
				return i + 1; // Return 1-based index
			}
		}
		
		// This shouldn't happen if the node is in its sibling list
		Core.getLogger(this.getClass().getName()).warn(
			String.format("[CalculateSiblingIndex] Node %s not found in sibling list, defaulting to position 1", 
				TreeNode.getTreeItemID())
		);
		return 1;
	}
	
	// END EXTRA CODE
}