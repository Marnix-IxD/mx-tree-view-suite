// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package treeviewsuite.actions;

import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.IMendixIdentifier;
import com.mendix.systemwideinterfaces.core.UserAction;
import java.util.*;

/**
 * Generates structure IDs for an entire tree or subtree.
 * This action calculates and sets both StructureID and SiblingIndex
 * for all nodes, enabling client-side structure ID generation.
 * 
 * Algorithm:
 * 1. Load all nodes (optionally filtered by root)
 * 2. Build parent-child relationships
 * 3. Process level by level (breadth-first)
 * 4. Calculate sibling indices and structure IDs
 * 5. Batch update all nodes
 * 
 * This enables the client to use just the SiblingIndex attribute
 * to deterministically generate matching structure IDs.
 */
public class GenerateStructureIdsForTree extends UserAction<java.lang.Boolean>
{
	private IMendixObject __RootNode;
	private treeviewsuite.proxies.TreeNode RootNode;
	private java.lang.Boolean updateExistingIds;
	private java.lang.Boolean generateForSubtreeOnly;

	public GenerateStructureIdsForTree(IContext context, IMendixObject _RootNode, java.lang.Boolean _updateExistingIds, java.lang.Boolean _generateForSubtreeOnly)
	{
		super(context);
		this.__RootNode = _RootNode;
		this.updateExistingIds = _updateExistingIds;
		this.generateForSubtreeOnly = _generateForSubtreeOnly;
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		this.RootNode = this.__RootNode == null ? null : treeviewsuite.proxies.TreeNode.initialize(getContext(), __RootNode);

		// BEGIN USER CODE
		
		// Load all nodes to process
		List<IMendixObject> nodesToProcess = loadNodesToProcess();
		
		if (nodesToProcess.isEmpty()) {
			Core.getLogger(this.getClass().getName()).info(
				"[GenerateStructureIdsForTree] No nodes to process"
			);
			return true;
		}
		
		Core.getLogger(this.getClass().getName()).info(
			String.format("[GenerateStructureIdsForTree] Processing %d nodes", nodesToProcess.size())
		);
		
		// Build parent-child map for efficient processing
		Map<String, List<IMendixObject>> childrenByParentId = buildParentChildMap(nodesToProcess);
		Map<String, IMendixObject> nodeByTreeItemId = buildNodeMap(nodesToProcess);
		
		// Process nodes level by level
		List<IMendixObject> modifiedNodes = new ArrayList<>();
		Set<String> processedNodes = new HashSet<>();
		
		// Start with root nodes
		List<IMendixObject> currentLevel = getRootNodes(nodesToProcess);
		int currentLevelNum = 1;
		
		while (!currentLevel.isEmpty()) {
			Core.getLogger(this.getClass().getName()).debug(
				String.format("[GenerateStructureIdsForTree] Processing level %d with %d nodes", 
					currentLevelNum, currentLevel.size())
			);
			
			// Sort current level by SortOrder
			sortBySortOrder(currentLevel);
			
			// Process each parent's children
			Map<String, List<IMendixObject>> siblingGroups = groupByParent(currentLevel);
			
			for (Map.Entry<String, List<IMendixObject>> entry : siblingGroups.entrySet()) {
				String parentId = entry.getKey();
				List<IMendixObject> siblings = entry.getValue();
				
				// Sort siblings by SortOrder
				sortBySortOrder(siblings);
				
				// Assign sibling indices and structure IDs
				for (int i = 0; i < siblings.size(); i++) {
					IMendixObject node = siblings.get(i);
					treeviewsuite.proxies.TreeNode treeNode = treeviewsuite.proxies.TreeNode.initialize(getContext(), node);
					
					// Skip if already processed
					String treeItemId = treeNode.getTreeItemID();
					if (processedNodes.contains(treeItemId)) {
						continue;
					}
					
					// Calculate sibling index (1-based)
					long siblingIndex = i + 1;
					
					// Generate structure ID
					String structureId = generateStructureId(treeNode, parentId, siblingIndex, nodeByTreeItemId);
					
					// Update node if needed
					boolean modified = false;
					
					if (treeNode.getSiblingIndex() == null || !treeNode.getSiblingIndex().equals(siblingIndex)) {
						treeNode.setSiblingIndex(siblingIndex);
						modified = true;
					}
					
					if (updateExistingIds || treeNode.getStructureID() == null || treeNode.getStructureID().isEmpty()) {
						if (!structureId.equals(treeNode.getStructureID())) {
							treeNode.setStructureID(structureId);
							modified = true;
						}
					}
					
					if (modified) {
						modifiedNodes.add(node);
					}
					
					processedNodes.add(treeItemId);
				}
			}
			
			// Get next level - children of current level
			List<IMendixObject> nextLevel = new ArrayList<>();
			for (IMendixObject node : currentLevel) {
				treeviewsuite.proxies.TreeNode treeNode = treeviewsuite.proxies.TreeNode.initialize(getContext(), node);
				String treeItemId = treeNode.getTreeItemID();
				
				List<IMendixObject> children = childrenByParentId.get(treeItemId);
				if (children != null) {
					nextLevel.addAll(children);
				}
			}
			
			currentLevel = nextLevel;
			currentLevelNum++;
		}
		
		// Commit all modified nodes
		if (!modifiedNodes.isEmpty()) {
			Core.getLogger(this.getClass().getName()).info(
				String.format("[GenerateStructureIdsForTree] Committing %d modified nodes", modifiedNodes.size())
			);
			
			// Batch commit for performance
			int batchSize = 1000;
			for (int i = 0; i < modifiedNodes.size(); i += batchSize) {
				int end = Math.min(i + batchSize, modifiedNodes.size());
				List<IMendixObject> batch = modifiedNodes.subList(i, end);
				Core.commitWithoutEvents(getContext(), batch);
			}
		}
		
		Core.getLogger(this.getClass().getName()).info(
			"[GenerateStructureIdsForTree] Structure ID generation completed successfully"
		);
		
		return true;
		
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "GenerateStructureIdsForTree";
	}

	// BEGIN EXTRA CODE
	
	/**
	 * Load nodes to process based on configuration
	 */
	private List<IMendixObject> loadNodesToProcess() throws Exception {
		if (generateForSubtreeOnly && RootNode != null) {
			// Get subtree starting from root node
			String rootTreeItemId = RootNode.getTreeItemID();
			String rootStructureId = RootNode.getStructureID();
			
			// If root has structure ID, use it for efficient subtree query
			if (rootStructureId != null && !rootStructureId.isEmpty()) {
				return Core.createXPathQuery(
					"//TreeViewSuite.TreeNode[starts-with(StructureID, $rootStructureId)]"
				)
				.addVariable("rootStructureId", rootStructureId)
				.execute(getContext());
			} else {
				// Fallback: load all and filter in memory (less efficient)
				List<IMendixObject> allNodes = Core.createXPathQuery("//TreeViewSuite.TreeNode")
					.execute(getContext());
				
				return filterSubtree(allNodes, rootTreeItemId);
			}
		} else {
			// Get all nodes
			return Core.createXPathQuery("//TreeViewSuite.TreeNode")
				.execute(getContext());
		}
	}
	
	/**
	 * Filter nodes to get only subtree
	 */
	private List<IMendixObject> filterSubtree(List<IMendixObject> allNodes, String rootTreeItemId) throws Exception {
		Map<String, List<IMendixObject>> childrenByParentId = buildParentChildMap(allNodes);
		List<IMendixObject> subtree = new ArrayList<>();
		
		// BFS to collect subtree
		Queue<String> queue = new LinkedList<>();
		queue.offer(rootTreeItemId);
		
		while (!queue.isEmpty()) {
			String currentId = queue.poll();
			
			// Find node
			for (IMendixObject node : allNodes) {
				treeviewsuite.proxies.TreeNode treeNode = treeviewsuite.proxies.TreeNode.initialize(getContext(), node);
				if (currentId.equals(treeNode.getTreeItemID())) {
					subtree.add(node);
					
					// Add children to queue
					List<IMendixObject> children = childrenByParentId.get(currentId);
					if (children != null) {
						for (IMendixObject child : children) {
							treeviewsuite.proxies.TreeNode childNode = treeviewsuite.proxies.TreeNode.initialize(getContext(), child);
							queue.offer(childNode.getTreeItemID());
						}
					}
					break;
				}
			}
		}
		
		return subtree;
	}
	
	/**
	 * Build parent-child relationship map
	 */
	private Map<String, List<IMendixObject>> buildParentChildMap(List<IMendixObject> nodes) throws Exception {
		Map<String, List<IMendixObject>> map = new HashMap<>();
		
		for (IMendixObject node : nodes) {
			treeviewsuite.proxies.TreeNode treeNode = treeviewsuite.proxies.TreeNode.initialize(getContext(), node);
			String parentId = treeNode.getParentTreeItemID();
			
			if (parentId != null && !parentId.isEmpty()) {
				map.computeIfAbsent(parentId, k -> new ArrayList<>()).add(node);
			}
		}
		
		return map;
	}
	
	/**
	 * Build node lookup map by TreeItemID
	 */
	private Map<String, IMendixObject> buildNodeMap(List<IMendixObject> nodes) throws Exception {
		Map<String, IMendixObject> map = new HashMap<>();
		
		for (IMendixObject node : nodes) {
			treeviewsuite.proxies.TreeNode treeNode = treeviewsuite.proxies.TreeNode.initialize(getContext(), node);
			map.put(treeNode.getTreeItemID(), node);
		}
		
		return map;
	}
	
	/**
	 * Get root nodes from list
	 */
	private List<IMendixObject> getRootNodes(List<IMendixObject> nodes) throws Exception {
		List<IMendixObject> roots = new ArrayList<>();
		
		for (IMendixObject node : nodes) {
			treeviewsuite.proxies.TreeNode treeNode = treeviewsuite.proxies.TreeNode.initialize(getContext(), node);
			String parentId = treeNode.getParentTreeItemID();
			
			if (parentId == null || parentId.isEmpty()) {
				roots.add(node);
			}
		}
		
		return roots;
	}
	
	/**
	 * Group nodes by parent
	 */
	private Map<String, List<IMendixObject>> groupByParent(List<IMendixObject> nodes) throws Exception {
		Map<String, List<IMendixObject>> groups = new HashMap<>();
		
		for (IMendixObject node : nodes) {
			treeviewsuite.proxies.TreeNode treeNode = treeviewsuite.proxies.TreeNode.initialize(getContext(), node);
			String parentId = treeNode.getParentTreeItemID();
			
			// Use empty string for root nodes
			String groupKey = (parentId != null && !parentId.isEmpty()) ? parentId : "";
			groups.computeIfAbsent(groupKey, k -> new ArrayList<>()).add(node);
		}
		
		return groups;
	}
	
	/**
	 * Sort nodes by SortOrder
	 */
	private void sortBySortOrder(List<IMendixObject> nodes) {
		Collections.sort(nodes, new Comparator<IMendixObject>() {
			@Override
			public int compare(IMendixObject a, IMendixObject b) {
				try {
					Integer sortOrderA = (Integer) a.getValue(getContext(), "SortOrder");
					Integer sortOrderB = (Integer) b.getValue(getContext(), "SortOrder");
					
					if (sortOrderA == null) sortOrderA = 0;
					if (sortOrderB == null) sortOrderB = 0;
					
					return sortOrderA.compareTo(sortOrderB);
				} catch (Exception e) {
					return 0;
				}
			}
		});
	}
	
	/**
	 * Generate structure ID for a node
	 */
	private String generateStructureId(treeviewsuite.proxies.TreeNode node, String parentTreeItemId, 
									   long siblingIndex, Map<String, IMendixObject> nodeMap) throws Exception {
		// Root node
		if (parentTreeItemId == null || parentTreeItemId.isEmpty()) {
			return siblingIndex + ".";
		}
		
		// Child node - need parent's structure ID
		IMendixObject parentObj = nodeMap.get(parentTreeItemId);
		if (parentObj != null) {
			treeviewsuite.proxies.TreeNode parentNode = treeviewsuite.proxies.TreeNode.initialize(getContext(), parentObj);
			String parentStructureId = parentNode.getStructureID();
			
			if (parentStructureId != null && !parentStructureId.isEmpty()) {
				return parentStructureId + siblingIndex + ".";
			}
		}
		
		// Fallback - this shouldn't happen if processing level by level
		Core.getLogger(this.getClass().getName()).warn(
			String.format("[GenerateStructureIdsForTree] Parent structure ID not found for node %s", 
				node.getTreeItemID())
		);
		
		return siblingIndex + ".";
	}
	
	// END EXTRA CODE
}