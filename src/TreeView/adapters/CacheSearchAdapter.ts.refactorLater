import { BaseSearchAdapter } from "./BaseSearchAdapter";
import {
    SearchMode,
    SearchFeature,
    ISearchOptions,
    ISearchResponse,
    IUnifiedSearchResult,
    IPerformanceEstimate,
    ISearchContext
} from "../types/UnifiedSearchTypes";
import { getSearchCache, SearchCache } from "../utils/searchCache";
import { SearchResult } from "../types/TreeTypes";

/**
 * Search adapter for LRU cache
 * Provides instant results from previously cached searches
 */
export class CacheSearchAdapter extends BaseSearchAdapter {
    readonly mode: SearchMode = "cache";
    readonly name = "Cache Search";
    readonly priority = 100; // Highest priority - always check cache first

    private cache: SearchCache;
    private context: ISearchContext;
    private cacheKey: string;

    constructor(context: ISearchContext, cacheSize?: number, cacheTTL?: number, cacheKey?: string) {
        super();
        this.context = context;

        // Use provided cache key or default
        // This allows different tree instances to have separate caches
        this.cacheKey = cacheKey || "default";

        // Get or create cache instance with custom settings
        this.cache = getSearchCache(this.cacheKey, cacheSize, cacheTTL);

        // Cache supports these features
        this.features = new Set([
            SearchFeature.PartialMatching,
            SearchFeature.OfflineSupport,
            SearchFeature.Highlighting
        ]);
    }

    /**
     * Cache is always available
     */
    isAvailable(): boolean {
        return true;
    }

    /**
     * Cache performance is nearly instant
     */
    estimatePerformance(options: ISearchOptions): IPerformanceEstimate {
        const cached = this.cache.get(options.query);

        return {
            estimatedTime: cached ? 1 : 0, // 1ms if cached, 0 if not
            confidence: 1.0, // Very high confidence
            factors: [cached ? "Result in cache" : "No cached result", `Cache size: ${this.cache.getStats().total}`]
        };
    }

    /**
     * Perform cache search
     */
    protected async performSearch(options: ISearchOptions): Promise<ISearchResponse> {
        const startTime = Date.now();

        // Check for exact match first
        let cachedResults = this.cache.get(options.query);

        // If no exact match and partial matching is enabled, try to find partial matches
        if (!cachedResults && options.query.length > 2) {
            const partialResults = this.cache.getPartialMatches(options.query);
            if (partialResults.length > 0) {
                // Use the most recent partial match
                cachedResults = partialResults[0].results;
            }
        }

        if (!cachedResults || cachedResults.length === 0) {
            return {
                results: [],
                total: 0,
                hasMore: false,
                cached: true,
                executionTime: Date.now() - startTime
            };
        }

        // Convert cached results to unified format
        const unifiedResults = this.convertToUnifiedResults(cachedResults, options);

        // Apply pagination if needed
        const page = options.page || 0;
        const pageSize = options.pageSize || 50;
        const startIndex = page * pageSize;
        const endIndex = startIndex + pageSize;

        const paginatedResults = unifiedResults.slice(startIndex, endIndex);

        // Since this is a cache hit, we can set hit rate to 100%
        this.stats.hitRate = 1.0;

        return {
            results: paginatedResults,
            total: unifiedResults.length,
            hasMore: endIndex < unifiedResults.length,
            cached: true,
            executionTime: Date.now() - startTime,
            nextOffset: endIndex < unifiedResults.length ? endIndex : undefined
        };
    }

    /**
     * Convert old SearchResult format to unified format
     */
    private convertToUnifiedResults(cachedResults: SearchResult[], _options: ISearchOptions): IUnifiedSearchResult[] {
        return cachedResults.map(result => {
            const node = this.context.nodes.get(result.nodeId);
            const objectItem = this.context.objectItems.get(result.nodeId);

            return {
                nodeId: result.nodeId,
                node,
                objectItem,
                matches: result.matches.map(match => ({
                    attribute: match.attribute,
                    value: match.value || "",
                    matchedText: match.matchedText,
                    highlights:
                        match.startIndex !== undefined && match.endIndex !== undefined
                            ? [
                                  {
                                      start: match.startIndex,
                                      end: match.endIndex
                                  }
                              ]
                            : undefined
                })),
                ancestors: this.findAncestors(result.nodeId),
                score: 1.0, // Cached results are exact matches, so highest score
                source: "cache",
                structureId: node?.structureId,
                level: node?.level
            };
        });
    }

    /**
     * Find ancestors for a node
     */
    private findAncestors(nodeId: string): string[] {
        const ancestors: string[] = [];
        const node = this.context.nodes.get(nodeId);

        if (!node) {
            return ancestors;
        }

        let currentNode = node;
        while (currentNode.parentId) {
            ancestors.unshift(currentNode.parentId);
            const parent = this.context.nodes.get(currentNode.parentId);
            if (!parent) {
                break;
            }
            currentNode = parent;
        }

        return ancestors;
    }

    /**
     * Clear the cache
     */
    clearCache(): void {
        this.cache.clear();
    }

    /**
     * Store results in cache (called by unified hook after other searches)
     */
    storeResults(query: string, results: SearchResult[]): void {
        this.cache.set(query, results);
    }

    /**
     * Get cache statistics
     */
    getCacheStats(): import("../utils/searchCache").CacheStats {
        return this.cache.getStats();
    }
}
