import { BaseSearchAdapter } from "./BaseSearchAdapter";
import {
    SearchMode,
    SearchFeature,
    ISearchOptions,
    ISearchResponse,
    IUnifiedSearchResult,
    IPerformanceEstimate,
    ISearchContext,
    ISearchMatch
} from "../types/UnifiedSearchTypes";
import { TreeNode } from "../types/TreeTypes";
import { WorkerManager, ISerializedNode } from "../utils/workerManager";
import { ListAttributeValue } from "mendix";
import { Big } from "big.js";

/**
 * Search adapter for client-side search using Web Workers
 * Performs search on loaded tree nodes for better performance with large datasets
 */
export class ClientSearchAdapter extends BaseSearchAdapter {
    readonly mode: SearchMode = "client";
    readonly name = "Client Search";
    readonly priority = 70; // Medium-high priority

    private context: ISearchContext;
    private workerManager: WorkerManager;
    private searchAttributes: Array<ListAttributeValue<string | Big | boolean | Date>>;
    private webWorkerThreshold: number;

    constructor(
        context: ISearchContext,
        searchAttributes: Array<ListAttributeValue<string | Big | boolean | Date>>,
        webWorkerThreshold = 100
    ) {
        super();
        this.context = context;
        this.searchAttributes = searchAttributes;
        this.webWorkerThreshold = webWorkerThreshold;
        this.workerManager = WorkerManager.getInstance();

        // Client search supports these features
        this.features = new Set([
            SearchFeature.OfflineSupport,
            SearchFeature.Highlighting,
            SearchFeature.PartialMatching,
            SearchFeature.FuzzySearch,
            SearchFeature.Cancellation
        ]);
    }

    /**
     * Check if client search is available
     */
    isAvailable(): boolean {
        // Need loaded nodes and search attributes
        return this.context.nodes.size > 0 && this.searchAttributes.length > 0;
    }

    /**
     * Estimate performance based on loaded nodes
     */
    estimatePerformance(options: ISearchOptions): IPerformanceEstimate {
        const nodeCount = this.context.nodes.size;
        const useWorker = nodeCount > this.webWorkerThreshold && this.workerManager.isAvailable();
        const factors: string[] = [];

        // Base time calculation
        let estimatedTime: number;

        if (useWorker) {
            // Web Worker is faster for large datasets
            estimatedTime = 50 + nodeCount / 50; // ~50ms base + 20ms per 1000 nodes
            factors.push("Using Web Worker");
        } else {
            // Main thread is slower
            estimatedTime = 10 + nodeCount / 10; // ~10ms base + 100ms per 1000 nodes
            factors.push("Using main thread");
        }

        factors.push(`${nodeCount} nodes loaded`);

        if (options.fuzzySearch) {
            estimatedTime *= 3; // Fuzzy search is much slower
            factors.push("Fuzzy search enabled");
        }

        return {
            estimatedTime: Math.min(estimatedTime, 500), // Cap at 500ms
            confidence: 0.8, // Good confidence
            factors
        };
    }

    /**
     * Perform client-side search
     */
    protected async performSearch(options: ISearchOptions): Promise<ISearchResponse> {
        const startTime = Date.now();
        const nodes = Array.from(this.context.nodes.values());

        // Decide whether to use Web Worker
        const useWorker = nodes.length > this.webWorkerThreshold && this.workerManager.isAvailable();

        let searchResults: IUnifiedSearchResult[];

        if (useWorker) {
            searchResults = await this.performWorkerSearch(nodes, options);
        } else {
            searchResults = await this.performMainThreadSearch(nodes, options);
        }

        // Check if aborted
        this.checkAborted(options.signal);

        // Sort by score
        searchResults.sort((a, b) => (b.score || 0) - (a.score || 0));

        // Apply pagination
        const page = options.page || 0;
        const pageSize = options.pageSize || 50;
        const startIndex = page * pageSize;
        const endIndex = startIndex + pageSize;

        const paginatedResults = searchResults.slice(startIndex, endIndex);

        return {
            results: paginatedResults,
            total: searchResults.length,
            hasMore: endIndex < searchResults.length,
            executionTime: Date.now() - startTime,
            nextOffset: endIndex < searchResults.length ? endIndex : undefined
        };
    }

    /**
     * Perform search using Web Worker
     */
    private async performWorkerSearch(nodes: TreeNode[], options: ISearchOptions): Promise<IUnifiedSearchResult[]> {
        // Serialize nodes for worker
        const serializedNodes: ISerializedNode[] = [];
        const searchableAttributes = options.searchAttributes || this.searchAttributes.map(attr => attr.id);

        for (const node of nodes) {
            if (!node.objectItem) {
                continue;
            }

            const serializedNode: any = {
                id: node.id,
                label: node.label,
                parentId: node.parentId,
                structureId: node.structureId,
                level: node.level
            };

            // Add searchable attribute values
            for (const attr of this.searchAttributes) {
                const value = attr.get(node.objectItem).value;
                if (value !== null && value !== undefined) {
                    serializedNode[attr.id] = value.toString();
                }
            }

            serializedNodes.push(serializedNode);
        }

        try {
            // Send to worker with progress tracking
            const workerResults = await this.workerManager.sendWork<any>(
                "search",
                options.fuzzySearch ? "FUZZY_SEARCH" : "SEARCH",
                {
                    nodes: serializedNodes,
                    query: options.query,
                    searchableAttributes,
                    caseSensitive: options.caseSensitive
                },
                progress => {
                    // Could emit progress events here
                    console.debug(`Search progress: ${progress.processed}/${progress.total}`);
                }
            );

            // Convert worker results to unified format
            return workerResults.results.map((result: any) => {
                const node = this.context.nodes.get(result.id);
                const objectItem = this.context.objectItems.get(result.id);

                return {
                    nodeId: result.id,
                    node,
                    objectItem,
                    matches: this.convertWorkerMatches(result.highlights || {}),
                    ancestors: this.findAncestors(result.id),
                    score: result.score || 0,
                    source: "client",
                    structureId: node?.structureId,
                    level: node?.level
                };
            });
        } catch (error) {
            console.warn("Worker search failed, falling back to main thread:", error);
            // Fall back to main thread search
            return this.performMainThreadSearch(nodes, options);
        }
    }

    /**
     * Perform search on main thread
     */
    private async performMainThreadSearch(nodes: TreeNode[], options: ISearchOptions): Promise<IUnifiedSearchResult[]> {
        const results: IUnifiedSearchResult[] = [];
        const query = options.query;
        const queryLower = query.toLowerCase();
        const searchAttributes = options.searchAttributes || this.searchAttributes.map(attr => attr.id);

        for (const node of nodes) {
            // Check if aborted periodically
            this.checkAborted(options.signal);

            if (!node.objectItem) {
                continue;
            }

            const matches: ISearchMatch[] = [];
            let nodeScore = 0;

            // Search in configured attributes
            for (const attr of this.searchAttributes) {
                if (!searchAttributes.includes(attr.id)) {
                    continue;
                }

                const value = attr.get(node.objectItem).value;
                if (value === null || value === undefined) {
                    continue;
                }

                const stringValue = value.toString();
                const valueLower = stringValue.toLowerCase();

                if (options.fuzzySearch) {
                    // Fuzzy search logic
                    const fuzzyScore = this.calculateFuzzyScore(queryLower, valueLower);
                    if (fuzzyScore > 0.6) {
                        // Threshold for fuzzy match
                        matches.push({
                            attribute: attr.id,
                            value: stringValue,
                            matchedText: query,
                            highlights: [] // Fuzzy search doesn't have exact positions
                        });
                        nodeScore += fuzzyScore * 100;
                    }
                } else {
                    // Exact substring search
                    const index = valueLower.indexOf(queryLower);
                    if (index !== -1) {
                        matches.push({
                            attribute: attr.id,
                            value: stringValue,
                            matchedText: stringValue.substring(index, index + query.length),
                            highlights: [
                                {
                                    start: index,
                                    end: index + query.length
                                }
                            ]
                        });
                        nodeScore += this.calculateExactScore(index, stringValue, query);
                    }
                }
            }

            if (matches.length > 0) {
                results.push({
                    nodeId: node.id,
                    node,
                    objectItem: node.objectItem,
                    matches,
                    ancestors: this.findAncestors(node.id),
                    score: nodeScore,
                    source: "client",
                    structureId: node.structureId,
                    level: node.level
                });
            }
        }

        return results;
    }

    /**
     * Convert worker highlight format to unified matches
     */
    private convertWorkerMatches(highlights: Record<string, any>): ISearchMatch[] {
        return Object.entries(highlights).map(([attr, highlight]) => ({
            attribute: attr,
            value: highlight.text || "",
            matchedText: highlight.matched || "",
            highlights:
                highlight.start !== undefined && highlight.end !== undefined
                    ? [
                          {
                              start: highlight.start,
                              end: highlight.end
                          }
                      ]
                    : []
        }));
    }

    /**
     * Calculate score for exact match
     */
    private calculateExactScore(index: number, value: string, query: string): number {
        let score = 50; // Base score for any match

        // Exact match
        if (value.toLowerCase() === query.toLowerCase()) {
            score += 50;
        }
        // Starts with query
        else if (index === 0) {
            score += 30;
        }
        // Word boundary match
        else if (index > 0 && value[index - 1] === " ") {
            score += 20;
        }

        // Length bonus (shorter values are more relevant)
        score += Math.max(0, 10 - value.length / 20);

        return score;
    }

    /**
     * Simple fuzzy scoring algorithm
     */
    private calculateFuzzyScore(query: string, value: string): number {
        // Simple character-based scoring
        let score = 0;
        let queryIndex = 0;

        for (let i = 0; i < value.length && queryIndex < query.length; i++) {
            if (value[i] === query[queryIndex]) {
                score++;
                queryIndex++;
            }
        }

        return queryIndex === query.length ? score / query.length : 0;
    }

    /**
     * Find ancestors for a node
     */
    private findAncestors(nodeId: string): string[] {
        const ancestors: string[] = [];
        const node = this.context.nodes.get(nodeId);

        if (!node) {
            return ancestors;
        }

        let currentNode = node;
        while (currentNode.parentId) {
            ancestors.unshift(currentNode.parentId);
            const parent = this.context.nodes.get(currentNode.parentId);
            if (!parent) {
                break;
            }
            currentNode = parent;
        }

        return ancestors;
    }
}
