import { BaseSearchAdapter } from "./BaseSearchAdapter";
import {
    SearchMode,
    SearchFeature,
    ISearchOptions,
    ISearchResponse,
    IUnifiedSearchResult,
    IPerformanceEstimate,
    ISearchContext,
    ISearchMatch
} from "../types/UnifiedSearchTypes";
import { MendixSessionSearch } from "../utils/mendixSessionSearch";
import { ListAttributeValue } from "mendix";
import { Big } from "big.js";

/**
 * Search adapter for Mendix session objects
 * Searches through mx.session.sessionData.objects for instant results
 */
export class SessionSearchAdapter extends BaseSearchAdapter {
    readonly mode: SearchMode = "session";
    readonly name = "Session Search";
    readonly priority = 90; // High priority - check after cache

    private sessionSearch: MendixSessionSearch;
    private context: ISearchContext;
    private searchAttributes: Array<ListAttributeValue<string | Big | boolean | Date>>;
    private nodeIdAttribute: ListAttributeValue<string | Big>;

    constructor(
        context: ISearchContext,
        nodeIdAttribute: ListAttributeValue<string | Big>,
        searchAttributes: Array<ListAttributeValue<string | Big | boolean | Date>>,
        entityType?: string
    ) {
        super();
        this.context = context;
        this.nodeIdAttribute = nodeIdAttribute;
        this.searchAttributes = searchAttributes;
        this.sessionSearch = new MendixSessionSearch();

        // Set entity type if provided
        if (entityType) {
            this.context.entityType = entityType;
        }

        // Session search supports these features
        this.features = new Set([
            SearchFeature.OfflineSupport,
            SearchFeature.Highlighting,
            SearchFeature.PartialMatching,
            SearchFeature.TypeAwareFiltering
        ]);
    }

    /**
     * Check if session search is available
     */
    isAvailable(): boolean {
        // Check if we have mx.session available
        if (typeof window === "undefined" || !(window as any).mx?.session?.sessionData?.objects) {
            return false;
        }

        // Check if we have entity type
        if (!this.context.entityType) {
            return false;
        }

        // Check if we have search attributes
        return this.searchAttributes.length > 0;
    }

    /**
     * Estimate performance based on session size
     */
    estimatePerformance(options: ISearchOptions): IPerformanceEstimate {
        const sessionCount = this.sessionSearch.countSessionObjects(this.context.entityType || "");
        const factors: string[] = [];

        // Base time depends on number of objects
        let estimatedTime = Math.min(5 + sessionCount / 100, 50); // 5-50ms

        factors.push(`${sessionCount} objects in session`);

        if (options.fuzzySearch) {
            estimatedTime *= 2;
            factors.push("Fuzzy search enabled");
        }

        return {
            estimatedTime,
            confidence: 0.9, // High confidence
            factors
        };
    }

    /**
     * Perform session search
     */
    protected async performSearch(options: ISearchOptions): Promise<ISearchResponse> {
        const startTime = Date.now();

        if (!this.context.entityType) {
            return {
                results: [],
                total: 0,
                hasMore: false,
                executionTime: Date.now() - startTime
            };
        }

        // Get attribute IDs for search
        const searchAttributeIds = options.searchAttributes || this.searchAttributes.map(attr => attr.id);

        // Perform the search
        const sessionResults = this.sessionSearch.searchSessionObjects(
            options.query,
            searchAttributeIds,
            this.context.entityType
        );

        // Check if aborted
        this.checkAborted(options.signal);

        // Convert to unified results
        const unifiedResults: IUnifiedSearchResult[] = [];

        for (const objectItem of sessionResults) {
            const nodeId = this.nodeIdAttribute.get(objectItem).value?.toString() || "";

            if (!nodeId) {
                continue;
            }

            // Find matches in the object
            const matches = this.findMatches(objectItem, options.query, searchAttributeIds);

            if (matches.length === 0) {
                continue;
            }

            const node = this.context.nodes.get(nodeId);

            unifiedResults.push({
                nodeId,
                node,
                objectItem,
                matches,
                ancestors: this.findAncestors(nodeId),
                score: this.calculateScore(matches, options.query),
                source: "session",
                structureId: node?.structureId,
                level: node?.level
            });
        }

        // Sort by score
        unifiedResults.sort((a, b) => (b.score || 0) - (a.score || 0));

        // Apply pagination
        const page = options.page || 0;
        const pageSize = options.pageSize || 50;
        const startIndex = page * pageSize;
        const endIndex = startIndex + pageSize;

        const paginatedResults = unifiedResults.slice(startIndex, endIndex);

        return {
            results: paginatedResults,
            total: unifiedResults.length,
            hasMore: endIndex < unifiedResults.length,
            executionTime: Date.now() - startTime,
            nextOffset: endIndex < unifiedResults.length ? endIndex : undefined
        };
    }

    /**
     * Find matches in object attributes
     */
    private findMatches(objectItem: any, query: string, attributeIds: string[]): ISearchMatch[] {
        const matches: ISearchMatch[] = [];
        const queryLower = query.toLowerCase();

        for (const attrId of attributeIds) {
            // Find the attribute definition
            const attrDef = this.searchAttributes.find(attr => attr.id === attrId);
            if (!attrDef) {
                continue;
            }

            const value = attrDef.get(objectItem).value;
            if (value === null || value === undefined) {
                continue;
            }

            const stringValue = value.toString();
            const valueLower = stringValue.toLowerCase();

            // Check for match
            const index = valueLower.indexOf(queryLower);
            if (index !== -1) {
                matches.push({
                    attribute: attrId,
                    attributeLabel: attrDef.id, // Could be enhanced with display names
                    value: stringValue,
                    matchedText: stringValue.substring(index, index + query.length),
                    highlights: [
                        {
                            start: index,
                            end: index + query.length
                        }
                    ]
                });
            }
        }

        return matches;
    }

    /**
     * Calculate relevance score
     */
    private calculateScore(matches: ISearchMatch[], query: string): number {
        let score = 0;
        const queryLower = query.toLowerCase();

        for (const match of matches) {
            const valueLower = match.value.toLowerCase();

            // Exact match gets highest score
            if (valueLower === queryLower) {
                score += 100;
            }
            // Starts with query
            else if (valueLower.startsWith(queryLower)) {
                score += 80;
            }
            // Word boundary match
            else if (
                match.highlights?.[0]?.start === 0 ||
                (match.highlights?.[0]?.start && match.value[match.highlights[0].start - 1] === " ")
            ) {
                score += 60;
            }
            // Contains match
            else {
                score += 40;
            }

            // Bonus for shorter values (more relevant)
            score += Math.max(0, 20 - match.value.length / 10);
        }

        return score;
    }

    /**
     * Find ancestors for a node
     */
    private findAncestors(nodeId: string): string[] {
        const ancestors: string[] = [];
        const node = this.context.nodes.get(nodeId);

        if (!node) {
            return ancestors;
        }

        let currentNode = node;
        while (currentNode.parentId) {
            ancestors.unshift(currentNode.parentId);
            const parent = this.context.nodes.get(currentNode.parentId);
            if (!parent) {
                break;
            }
            currentNode = parent;
        }

        return ancestors;
    }

    /**
     * Get session statistics
     */
    getSessionStats(): {
        entityType: string | undefined;
        objectCount: number;
        searchableAttributes: number;
    } {
        return {
            entityType: this.context.entityType,
            objectCount: this.sessionSearch.countSessionObjects(this.context.entityType || ""),
            searchableAttributes: this.searchAttributes.length
        };
    }
}
