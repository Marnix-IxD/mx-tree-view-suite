import {
    ISearchAdapter,
    SearchMode,
    SearchFeature,
    ISearchOptions,
    ISearchResponse,
    IPerformanceEstimate,
    IAdapterStats,
    ISearchError
} from "../types/UnifiedSearchTypes";

/**
 * Base class for search adapters providing common functionality
 */
export abstract class BaseSearchAdapter implements ISearchAdapter {
    abstract readonly mode: SearchMode;
    abstract readonly name: string;
    abstract readonly priority: number;

    protected stats: IAdapterStats = {
        totalSearches: 0,
        averageTime: 0,
        errors: 0,
        lastUsed: undefined
    };

    protected abortController: AbortController | null = null;
    protected searchStartTime = 0;

    /**
     * Default feature support - override in subclasses
     */
    protected features = new Set<SearchFeature>([SearchFeature.PartialMatching]);

    /**
     * Check if adapter is available
     */
    abstract isAvailable(): boolean;

    /**
     * Perform the actual search
     */
    // eslint-disable-next-line no-unused-vars -- Abstract method parameter is used in implementations
    protected abstract performSearch(options: ISearchOptions): Promise<ISearchResponse>;

    /**
     * Check feature support
     */
    supports(feature: SearchFeature): boolean {
        return this.features.has(feature);
    }

    /**
     * Estimate performance - override for specific implementations
     */
    estimatePerformance(options: ISearchOptions): IPerformanceEstimate {
        // Base estimation logic
        const factors: string[] = [];
        let estimatedTime = 100; // Base time in ms

        if (options.fuzzySearch) {
            estimatedTime *= 2;
            factors.push("Fuzzy search enabled");
        }

        if (options.includeAncestors) {
            estimatedTime *= 1.5;
            factors.push("Ancestor expansion required");
        }

        return {
            estimatedTime,
            confidence: 0.5, // Low confidence for base implementation
            factors
        };
    }

    /**
     * Main search method with stats tracking
     */
    async search(options: ISearchOptions): Promise<ISearchResponse> {
        // Cancel any ongoing search
        this.cancel();

        // Create new abort controller
        this.abortController = new AbortController();
        const signal = options.signal || this.abortController.signal;

        // Start timing
        this.searchStartTime = Date.now();
        this.stats.lastUsed = new Date();
        this.stats.totalSearches++;

        try {
            // Perform the search with abort signal
            const response = await this.performSearch({
                ...options,
                signal
            });

            // Update stats on success
            const executionTime = Date.now() - this.searchStartTime;
            this.updateAverageTime(executionTime);

            return {
                ...response,
                executionTime: response.executionTime || executionTime
            };
        } catch (error: any) {
            this.stats.errors++;

            // Handle abort
            if (error.name === "AbortError" || signal.aborted) {
                throw new Error("Search cancelled");
            }

            // Create error response
            const searchError: ISearchError = {
                adapter: this.mode,
                message: error.message || "Unknown error",
                code: error.code,
                recoverable: this.isRecoverableError(error)
            };

            return {
                results: [],
                total: 0,
                hasMore: false,
                errors: [searchError],
                executionTime: Date.now() - this.searchStartTime
            };
        } finally {
            this.abortController = null;
        }
    }

    /**
     * Cancel ongoing search
     */
    cancel(): void {
        if (this.abortController) {
            this.abortController.abort();
            this.abortController = null;
        }
    }

    /**
     * Get adapter statistics
     */
    getStats(): IAdapterStats {
        return { ...this.stats };
    }

    /**
     * Clear cache - override in adapters with caching
     */
    clearCache(): void {
        // Base implementation does nothing
    }

    /**
     * Update average execution time
     */
    protected updateAverageTime(newTime: number): void {
        const totalTime = this.stats.averageTime * (this.stats.totalSearches - 1) + newTime;
        this.stats.averageTime = Math.round(totalTime / this.stats.totalSearches);
    }

    /**
     * Check if error is recoverable
     */
    protected isRecoverableError(error: any): boolean {
        // Network errors are often recoverable
        if (error.code === "ECONNREFUSED" || error.code === "ETIMEDOUT") {
            return true;
        }

        // Timeout errors are recoverable
        if (error.name === "TimeoutError") {
            return true;
        }

        return false;
    }

    /**
     * Helper to check if search was aborted
     */
    protected checkAborted(signal?: AbortSignal): void {
        if (signal?.aborted) {
            throw new Error("Search cancelled");
        }
    }

    /**
     * Helper to create timeout promise
     */
    protected createTimeoutPromise(timeout: number, signal?: AbortSignal): Promise<never> {
        return new Promise((_, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error(`Search timeout after ${timeout}ms`));
            }, timeout);

            // Clear timeout if aborted
            signal?.addEventListener("abort", () => {
                clearTimeout(timeoutId);
                reject(new Error("Search cancelled"));
            });
        });
    }
}
