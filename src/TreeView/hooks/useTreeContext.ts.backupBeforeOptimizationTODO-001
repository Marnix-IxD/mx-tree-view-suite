import { useEffect, useRef } from "react";
import { EditableValue } from "mendix";
import { setTimer, clearTimer, TimerId } from "../utils/timers";

interface TreeContextProps {
    selectedPartIdAttribute: EditableValue<string>;
    selectedStructureIdAttribute: EditableValue<string>;
    focusedPartIdAttribute: EditableValue<string>;
    focusedStructureIdAttribute: EditableValue<string>;
    hoveredPartIdAttribute: EditableValue<string>;
    hoveredStructureIdAttribute: EditableValue<string>;
}

interface TreeContextState {
    selectedPartIds: string[];
    selectedStructureIds: string[];
    focusedPartId: string | null;
    focusedStructureId: string | null;
    hoveredPartId: string | null;
    hoveredStructureId: string | null;
}

interface TreeContextActions {
    setSelectedNodes: (partIds: string[], structureIds: string[]) => void;
    setFocusedNode: (partId: string | null, structureId: string | null) => void;
    setHoveredNode: (partId: string | null, structureId: string | null) => void;
}

export function useTreeContext(props: TreeContextProps, state: TreeContextState, actions: TreeContextActions): void {
    const {
        selectedPartIdAttribute,
        selectedStructureIdAttribute,
        focusedPartIdAttribute,
        focusedStructureIdAttribute,
        hoveredPartIdAttribute,
        hoveredStructureIdAttribute
    } = props;

    const {
        selectedPartIds,
        selectedStructureIds,
        focusedPartId,
        focusedStructureId,
        hoveredPartId,
        hoveredStructureId
    } = state;
    const { setSelectedNodes, setFocusedNode, setHoveredNode } = actions;

    // Track previous values to detect external changes
    const prevSelectedRef = useRef<string>("");
    const prevFocusedRef = useRef<string>("");
    const prevHoveredRef = useRef<string>("");
    
    // Track if we're currently updating to prevent feedback loops
    const isUpdatingRef = useRef(false);
    
    // Track last focus change time to prevent rapid changes
    const lastFocusChangeRef = useRef<number>(0);
    const FOCUS_DEBOUNCE_MS = 200;

    // Debounce timer for hover updates
    const hoverDebounceRef = useRef<TimerId | null>(null);

    // Update Mendix attributes when state changes
    useEffect(() => {
        if (
            selectedPartIdAttribute &&
            selectedPartIdAttribute.status === "available" &&
            selectedPartIdAttribute.value !== selectedPartIds.join(",")
        ) {
            selectedPartIdAttribute.setValue(selectedPartIds.join(","));
        }
        if (
            selectedStructureIdAttribute &&
            selectedStructureIdAttribute.status === "available" &&
            selectedStructureIdAttribute.value !== selectedStructureIds.join(",")
        ) {
            selectedStructureIdAttribute.setValue(selectedStructureIds.join(","));
        }
    }, [selectedPartIds, selectedStructureIds, selectedPartIdAttribute, selectedStructureIdAttribute]);

    useEffect(() => {
        if (
            focusedPartIdAttribute &&
            focusedPartIdAttribute.status === "available" &&
            focusedPartIdAttribute.value !== (focusedPartId || "")
        ) {
            console.debug(`useTreeContext [NODE][FOCUS] Setting focusedPartIdAttribute from "${focusedPartIdAttribute.value}" to "${focusedPartId || ""}"`);
            isUpdatingRef.current = true;
            focusedPartIdAttribute.setValue(focusedPartId || "");
            // Reset flag after a short delay to allow the change to propagate
            setTimeout(() => {
                isUpdatingRef.current = false;
            }, 100);
        }
        if (
            focusedStructureIdAttribute &&
            focusedStructureIdAttribute.status === "available" &&
            focusedStructureIdAttribute.value !== (focusedStructureId || "")
        ) {
            focusedStructureIdAttribute.setValue(focusedStructureId || "");
        }
    }, [focusedPartId, focusedStructureId, focusedPartIdAttribute, focusedStructureIdAttribute]);

    // Debounced hover updates to avoid excessive attribute updates
    useEffect(() => {
        clearTimer(hoverDebounceRef.current);

        hoverDebounceRef.current = setTimer(() => {
            if (
                hoveredPartIdAttribute &&
                hoveredPartIdAttribute.status === "available" &&
                hoveredPartIdAttribute.value !== (hoveredPartId || "")
            ) {
                hoveredPartIdAttribute.setValue(hoveredPartId || "");
            }
            if (
                hoveredStructureIdAttribute &&
                hoveredStructureIdAttribute.status === "available" &&
                hoveredStructureIdAttribute.value !== (hoveredStructureId || "")
            ) {
                hoveredStructureIdAttribute.setValue(hoveredStructureId || "");
            }
        }, 150); // Debounce hover updates to 150ms

        return () => {
            clearTimer(hoverDebounceRef.current);
        };
    }, [hoveredPartId, hoveredStructureId, hoveredPartIdAttribute, hoveredStructureIdAttribute]);

    // Listen for external attribute changes
    useEffect(() => {
        if (
            selectedPartIdAttribute &&
            selectedPartIdAttribute.status === "available" &&
            selectedStructureIdAttribute &&
            selectedStructureIdAttribute.status === "available"
        ) {
            const currentSelected = selectedPartIdAttribute.value || "";

            if (currentSelected !== prevSelectedRef.current && currentSelected !== selectedPartIds.join(",")) {
                // External change detected
                prevSelectedRef.current = currentSelected;
                const partIds = currentSelected ? currentSelected.split(",").filter(Boolean) : [];
                const structureIds = (selectedStructureIdAttribute.value || "").split(",").filter(Boolean);

                // Validate that partIds and structureIds arrays have matching lengths
                if (partIds.length !== structureIds.length) {
                    console.warn(
                        `TreeView: Mismatched selection arrays - ${partIds.length} part IDs vs ${structureIds.length} structure IDs. ` +
                            `Using shorter array length to prevent errors.`
                    );
                    const minLength = Math.min(partIds.length, structureIds.length);
                    setSelectedNodes(partIds.slice(0, minLength), structureIds.slice(0, minLength));
                } else {
                    setSelectedNodes(partIds, structureIds);
                }
            }
        }
    }, [selectedPartIdAttribute?.value, selectedStructureIdAttribute?.value, selectedPartIds, setSelectedNodes]);

    useEffect(() => {
        if (
            focusedPartIdAttribute &&
            focusedPartIdAttribute.status === "available" &&
            focusedStructureIdAttribute &&
            focusedStructureIdAttribute.status === "available"
        ) {
            const currentFocused = focusedPartIdAttribute.value || "";

            if (currentFocused !== prevFocusedRef.current && currentFocused !== (focusedPartId || "")) {
                // Check if we're currently updating to prevent feedback loops
                if (isUpdatingRef.current) {
                    console.debug(`useTreeContext [NODE][FOCUS] Ignoring attribute change during update - from "${focusedPartId || ""}" to "${currentFocused}"`);
                    prevFocusedRef.current = currentFocused;
                    return;
                }
                
                // Check if this change is happening too quickly after the last one
                const now = Date.now();
                const timeSinceLastChange = now - lastFocusChangeRef.current;
                if (timeSinceLastChange < FOCUS_DEBOUNCE_MS) {
                    console.debug(`useTreeContext [NODE][FOCUS] Ignoring rapid focus change (${timeSinceLastChange}ms since last) - from "${focusedPartId || ""}" to "${currentFocused}"`);
                    return;
                }
                
                // External change detected
                console.debug(`useTreeContext [NODE][FOCUS] External focus change detected - from "${focusedPartId || ""}" to "${currentFocused}"`);
                prevFocusedRef.current = currentFocused;
                lastFocusChangeRef.current = now;
                const partId = currentFocused || null;
                const structureId = focusedStructureIdAttribute.value || null;
                setFocusedNode(partId, structureId);
            }
        }
    }, [focusedPartIdAttribute?.value, focusedStructureIdAttribute?.value, focusedPartId, setFocusedNode]);

    useEffect(() => {
        if (
            hoveredPartIdAttribute &&
            hoveredPartIdAttribute.status === "available" &&
            hoveredStructureIdAttribute &&
            hoveredStructureIdAttribute.status === "available"
        ) {
            const currentHovered = hoveredPartIdAttribute.value || "";

            if (currentHovered !== prevHoveredRef.current && currentHovered !== (hoveredPartId || "")) {
                // External change detected
                prevHoveredRef.current = currentHovered;
                const partId = currentHovered || null;
                const structureId = hoveredStructureIdAttribute.value || null;
                setHoveredNode(partId, structureId);
            }
        }
    }, [hoveredPartIdAttribute?.value, hoveredStructureIdAttribute?.value, hoveredPartId, setHoveredNode]);
}
