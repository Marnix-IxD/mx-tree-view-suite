import { ReactElement, createElement, useCallback, useMemo, Fragment, memo } from "react";
import classNames from "classnames";
import { TreeNode, SelectionMode } from "../../types/TreeTypes";
import { DynamicValue, WebIcon, ListWidgetValue, ListAttributeValue, ListExpressionValue } from "mendix";
import { Icon } from "../../icons/Icon";

// Constants
const INDENT_SIZE_DEFAULT = 20;
const ICON_SIZE = 16;
const VISIBILITY_TOGGLE_SIZE = 20;

interface ITreeNodeComponentProps {
    // Node data
    node: TreeNode;
    level: number;

    // State flags
    isSelected: boolean;
    isHighlighted: boolean;
    isFocused: boolean;
    isHovered: boolean;
    isExpanded: boolean;
    isVisible: boolean;
    isSticky: boolean;
    isDragging?: boolean;
    isDraggedOver?: boolean;
    dropPosition?: "before" | "inside" | "after" | null;

    // Event handlers
    onClick: () => void;
    onHover: () => void;
    onContextMenu: (e: React.MouseEvent) => void;
    onToggleExpanded: (e?: React.MouseEvent) => void;
    onToggleVisibility: () => void;

    // Drag & Drop handlers
    onDragStart?: (e: React.DragEvent) => void;
    onDragOver?: (e: React.DragEvent) => void;
    onDragLeave?: (e: React.DragEvent) => void;
    onDrop?: (e: React.DragEvent) => void;
    onDragEnd?: (e: React.DragEvent) => void;

    // Configuration
    selectionMode: SelectionMode;
    enableVisibilityToggle: boolean;
    enableDragDrop?: boolean;
    nodeContent?: ListWidgetValue;

    // Node label configuration
    nodeLabelType: "attribute" | "expression" | "widget";
    nodeLabelAttribute?: ListAttributeValue<string>;
    nodeLabelExpression?: ListExpressionValue<string>;
    nodeLabelContent?: ListWidgetValue;

    indentSize: number;
    showLines: boolean;
    showIcons: boolean;

    // Icons
    expandIcon?: DynamicValue<WebIcon>;
    collapseIcon?: DynamicValue<WebIcon>;
    visibilityOnIcon?: DynamicValue<WebIcon>;
    visibilityOffIcon?: DynamicValue<WebIcon>;
}

/**
 * TreeNodeComponent - Renders a single tree node with all interactive features
 * Highly optimized for performance with thousands of nodes
 */
export function TreeNodeComponent(props: ITreeNodeComponentProps): ReactElement {
    const {
        node,
        level,
        isSelected,
        isHighlighted,
        isFocused,
        isHovered,
        isExpanded,
        isVisible,
        isSticky,
        isDragging = false,
        isDraggedOver = false,
        dropPosition = null,
        onClick,
        onHover,
        onContextMenu,
        onToggleExpanded,
        onToggleVisibility,
        onDragStart,
        onDragOver,
        onDragLeave,
        onDrop,
        onDragEnd,
        selectionMode,
        enableVisibilityToggle,
        enableDragDrop = false,
        nodeContent,
        nodeLabelType,
        nodeLabelAttribute,
        nodeLabelExpression,
        nodeLabelContent,
        indentSize = INDENT_SIZE_DEFAULT,
        showLines,
        showIcons,
        expandIcon,
        collapseIcon,
        visibilityOnIcon,
        visibilityOffIcon
    } = props;

    // Calculate indentation
    const indent = useMemo(() => level * indentSize, [level, indentSize]);

    // Get node label based on type
    const nodeLabel = useMemo(() => {
        switch (nodeLabelType) {
            case "attribute":
                if (nodeLabelAttribute) {
                    const value = nodeLabelAttribute.get(node.objectItem).value;
                    return value || node.id;
                }
                return node.id;

            case "expression":
                if (nodeLabelExpression) {
                    const value = nodeLabelExpression.get(node.objectItem).value;
                    return value || node.id;
                }
                return node.id;

            case "widget":
                // For widget type, we'll render it in renderContent
                return null;

            default:
                return node.id;
        }
    }, [node, nodeLabelType, nodeLabelAttribute, nodeLabelExpression]);

    // Handle mouse enter for hover
    const handleMouseEnter = useCallback(() => {
        onHover();
    }, [onHover]);

    // Handle keyboard interaction
    const handleKeyDown = useCallback(
        (e: React.KeyboardEvent) => {
            switch (e.key) {
                case "Enter":
                case " ":
                    e.preventDefault();
                    onClick();
                    break;
                case "ArrowRight":
                    if (!isExpanded && node.children.length > 0) {
                        e.preventDefault();
                        onToggleExpanded();
                    }
                    break;
                case "ArrowLeft":
                    if (isExpanded && node.children.length > 0) {
                        e.preventDefault();
                        onToggleExpanded();
                    }
                    break;
            }
        },
        [onClick, onToggleExpanded, isExpanded, node.children.length]
    );

    // Check if device is touch-enabled
    const isTouchDevice = useMemo(() => {
        if (typeof window === "undefined") {
            return false;
        }
        return "ontouchstart" in window || navigator.maxTouchPoints > 0;
    }, []);

    // Render drag handle
    const renderDragHandle = () => {
        if (!enableDragDrop) {
            return null;
        }

        // Always show on touch devices, otherwise show on hover
        const showHandle = isTouchDevice || isHovered;

        return (
            <div
                className={classNames("mx-tree__node-drag-handle", {
                    "mx-tree__node-drag-handle--visible": showHandle,
                    "mx-tree__node-drag-handle--touch": isTouchDevice
                })}
                draggable
                onMouseDown={e => {
                    // Only the handle should initiate drag, not the whole node
                    e.stopPropagation();
                }}
                onDragStart={e => {
                    // Forward the drag start event with the node data
                    if (onDragStart) {
                        onDragStart(e as any);
                    }
                }}
                aria-label="Drag handle"
                style={{ width: 20 }}
            >
                <span className="mx-tree__node-drag-handle-icon">⋮⋮</span>
            </div>
        );
    };

    // Render expand/collapse icon
    const renderExpandIcon = () => {
        if (!showIcons || node.children.length === 0) {
            // Render empty space for alignment
            return <span className="mx-tree__node-expand-spacer" style={{ width: ICON_SIZE }} />;
        }

        const icon = isExpanded ? collapseIcon : expandIcon;

        return (
            <button
                className="mx-tree__node-expand-button"
                onClick={onToggleExpanded}
                onMouseDown={e => e.preventDefault()} // Prevent focus shift
                aria-label={isExpanded ? "Collapse" : "Expand"}
                tabIndex={-1}
            >
                <Icon
                    icon={icon}
                    fallback={isExpanded ? "chevron-down" : "chevron"}
                    className="mx-tree__node-expand-icon-svg"
                />
            </button>
        );
    };

    // Render visibility toggle
    const renderVisibilityToggle = () => {
        if (!enableVisibilityToggle) {
            return null;
        }

        const icon = isVisible ? visibilityOnIcon : visibilityOffIcon;

        return (
            <button
                className="mx-tree__node-visibility-button"
                onClick={e => {
                    e.stopPropagation();
                    onToggleVisibility();
                }}
                onMouseDown={e => e.preventDefault()} // Prevent focus shift
                aria-label={isVisible ? "Hide" : "Show"}
                tabIndex={-1}
                style={{ width: VISIBILITY_TOGGLE_SIZE }}
            >
                <Icon
                    icon={icon}
                    fallback={isVisible ? "eye-open" : "eye-closed"}
                    className="mx-tree__node-visibility-icon-svg"
                />
            </button>
        );
    };

    // Render selection indicator
    const renderSelectionIndicator = () => {
        if (selectionMode === "none") {
            return null;
        }

        if (selectionMode === "multiple") {
            return (
                <input
                    type="checkbox"
                    className="mx-tree__node-checkbox"
                    checked={isSelected}
                    onChange={() => {
                        /* Handled by onClick */
                    }} // TODO REVIEW TOMORROW - Empty function could be flagged by linter
                    onClick={e => e.stopPropagation()} // Prevent double handling
                    tabIndex={-1}
                    aria-label={`Select ${nodeLabel}`}
                />
            );
        }

        // Single selection mode
        return (
            <input
                type="radio"
                className="mx-tree__node-radio"
                checked={isSelected}
                onChange={() => {}} // Handled by onClick
                onClick={e => e.stopPropagation()} // Prevent double handling
                tabIndex={-1}
                aria-label={`Select ${nodeLabel}`}
            />
        );
    };

    // TODO ADD: Add support for tri-state checkboxes for parent nodes with partially selected children
    // TODO ADD: Add keyboard shortcuts for checkbox selection (Space key)
    // TODO REFACTOR: Consider using custom checkbox components for better styling control

    // Render node content
    const renderContent = () => {
        // If nodeContent is provided, use it for the entire node content
        if (nodeContent) {
            return <div className="mx-tree__node-custom-content">{nodeContent.get(node.objectItem)}</div>;
        }

        // Otherwise, render based on label type
        if (nodeLabelType === "widget" && nodeLabelContent) {
            // Custom widget for label only
            return <div className="mx-tree__node-label-widget">{nodeLabelContent.get(node.objectItem)}</div>;
        }

        // Default label rendering (for attribute or expression types)
        return <span className="mx-tree__node-label">{nodeLabel}</span>;
    };

    // Render connecting lines if enabled
    const renderLines = () => {
        if (!showLines) {
            return null;
        }

        return (
            <span className="mx-tree__node-lines" style={{ width: indent }} aria-hidden="true">
                {/* Vertical lines for each level */}
                {Array.from({ length: level }).map((_, i) => (
                    <span
                        key={i}
                        className="mx-tree__node-line-vertical"
                        style={{ left: i * indentSize + indentSize / 2 }}
                    />
                ))}
                {/* Horizontal line to this node */}
                <span
                    className="mx-tree__node-line-horizontal"
                    style={{
                        left: (level - 1) * indentSize + indentSize / 2,
                        width: indentSize / 2
                    }}
                />
            </span>
        );
    };

    return (
        <Fragment>
            {/* Drop indicator before */}
            {isDraggedOver && dropPosition === "before" && (
                <div
                    className="mx-tree__drop-indicator mx-tree__drop-indicator--before"
                    style={{ marginLeft: indent }}
                />
            )}

            <div
                className={classNames("mx-tree__node", {
                    "mx-tree__node--selected": isSelected,
                    "mx-tree__node--highlighted": isHighlighted,
                    "mx-tree__node--focused": isFocused,
                    "mx-tree__node--hovered": isHovered,
                    "mx-tree__node--expanded": isExpanded,
                    "mx-tree__node--collapsed": !isExpanded && node.children.length > 0,
                    "mx-tree__node--leaf": node.children.length === 0,
                    "mx-tree__node--parent": node.children.length > 0,
                    "mx-tree__node--visible": isVisible,
                    "mx-tree__node--hidden": !isVisible,
                    "mx-tree__node--sticky": isSticky,
                    "mx-tree__node--dragging": isDragging,
                    "mx-tree__node--dragged-over": isDraggedOver,
                    "mx-tree__node--drop-inside": isDraggedOver && dropPosition === "inside",
                    [`mx-tree__node--level-${level}`]: true
                })}
                onClick={onClick}
                onMouseEnter={handleMouseEnter}
                onContextMenu={onContextMenu}
                onKeyDown={handleKeyDown}
                role="treeitem"
                aria-expanded={node.children.length > 0 ? isExpanded : undefined}
                aria-selected={isSelected}
                aria-level={level + 1}
                tabIndex={isFocused ? 0 : -1}
                draggable={false}
                onDragOver={onDragOver}
                onDragLeave={onDragLeave}
                onDrop={onDrop}
                onDragEnd={onDragEnd}
                style={{
                    paddingLeft: showLines ? 0 : indent,
                    opacity: isDragging ? 0.5 : 1
                }}
            >
                {/* Connecting lines */}
                {renderLines()}

                {/* Node content container */}
                <div className="mx-tree__node-content">
                    {/* Drag handle */}
                    {renderDragHandle()}

                    {/* Expand/collapse icon */}
                    {renderExpandIcon()}

                    {/* Selection indicator */}
                    {renderSelectionIndicator()}

                    {/* Main content */}
                    {renderContent()}

                    {/* Visibility toggle */}
                    {renderVisibilityToggle()}
                </div>
            </div>

            {/* Drop indicator after */}
            {isDraggedOver && dropPosition === "after" && (
                <div
                    className="mx-tree__drop-indicator mx-tree__drop-indicator--after"
                    style={{ marginLeft: indent }}
                />
            )}
        </Fragment>
    );
}

// Memoize for performance
export default memo(TreeNodeComponent, (prevProps, nextProps) => {
    // Custom comparison for performance
    // Only re-render if relevant props changed
    return (
        prevProps.node.id === nextProps.node.id &&
        prevProps.isSelected === nextProps.isSelected &&
        prevProps.isHighlighted === nextProps.isHighlighted &&
        prevProps.isFocused === nextProps.isFocused &&
        prevProps.isHovered === nextProps.isHovered &&
        prevProps.isExpanded === nextProps.isExpanded &&
        prevProps.isVisible === nextProps.isVisible &&
        prevProps.isSticky === nextProps.isSticky &&
        prevProps.isDragging === nextProps.isDragging &&
        prevProps.isDraggedOver === nextProps.isDraggedOver &&
        prevProps.dropPosition === nextProps.dropPosition &&
        prevProps.level === nextProps.level
    );
});
